{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"Reloaded-II File Emulation Framework \ud83c\udf88 Let's screw with binaries \ud83c\udf88 <p>A framework for creating virtual files at runtime.</p>"},{"location":"index.html#about-the-framework","title":"About The Framework","text":"<p>The file emulation framework is a framework for intercepting Windows API calls related to the reading of files from disk; in order to trick games into loading files that don't really exist.  </p> <p>It builds on top of previous experiments with Reloaded, namely AFS Redirector, ONE Redirector and Persona 4 Golden PC modloader.  </p>"},{"location":"index.html#a-user-friendly-example","title":"A User Friendly Example","text":"<p>Replacing files inside big archives without creating new ones.  </p> <p></p> <p></p> <p>In this case, the following files would replace the 7th, 8th, 9th and 10th file in the <code>SH_VOICE_E.afs</code> archive.  </p>"},{"location":"index.html#how-it-works","title":"How It Works","text":"<p>By intercepting API calls used to open files, get their properties and read from them, we can essentially create files 'on the fly'; allowing us to perform various forms of post processing such as merging archives in a way that requires zero knowledge of the application running under the hood.</p> <p>In practice this is extremely effective, the original AFS Redirector is known for being able to work with 10+ games, including those behind emulators.</p> <p>Projects using this framework are referred to as 'emulators' hence the name <code>File Emulation Framework</code>; that name is derived from the original projects which simulated nonexistent archive files.</p>"},{"location":"index.html#performance-impact","title":"Performance Impact","text":"<p>This one varies with a lot of factors, such as number of emulators used, the emulators themselves, amount of data emulated, etc.</p> <p>In most realistic use cases, the emulators usually have negligible performance impact that is completely invisible to the end user. </p> <p>Usually first access to a file may be delayed for a small amount of time (<code>1-3ms on existing emulators at time of writing</code>) but this should usually be invisible to the end user. Penalty in speed of access to data of emulated files is negligible in practice. </p> <p>The biggest penalty tends to be from reading multiple files instead of just one; as the benefits of purely sequential reads may no longer apply.</p>"},{"location":"index.html#how-to-contribute-wiki","title":"How to Contribute (Wiki)","text":"<ul> <li>Contributing to the Wiki: Online</li> <li>Contributing to the Wiki: Locally</li> </ul>"},{"location":"index.html#credits-attributions","title":"Credits, Attributions","text":"<ul> <li>Header icon created by Freepik - Flaticon</li> </ul>"},{"location":"emulator-types.html","title":"Emulator Types","text":"<p>Info</p> <p>Describes the rules, and the two possible <code>'types'</code>/ways of implementing emulators.  </p>"},{"location":"emulator-types.html#type-a-stream-based","title":"Type A (Stream Based)","text":"<p>Info</p> <p>One way to produce emulators is through the use of 'streaming'. That is, keeping the minimal amount of information on how to construct the file in memory, while building the rest of the file on the fly as the application requests it.  </p> <p>In the case of archives, usually applications will read the header of the file, store it, and use that metadata to make further reads from the file.  You should replicate this sort of workflow.</p> <p>In this case of archives, you would usually produce the whole header of your new virtual archive and store it in memory.  Then as the application creates requests to read the data of the files inside, automatically load said data using either the original archive file, or using new files from the filesystem. </p> <p>Tip</p> <p>Always implement emulators using this technique, if possible. It may be a bit harder, but is far more optimal approach performance wise.</p>"},{"location":"emulator-types.html#type-b-non-stream-based","title":"Type B (Non-stream Based)","text":"<p>Info</p> <p>In some cases, the stream approach might not make sense; for example in cases where parts of old files might not be directly reusable, or simply hard to reuse.  </p> <p>One example of this kind of situation is with combining text/code/scripts. </p> <p>In this case, you should simply merge the files manually, to produce a new standalone file, just like you would with a regular program.  </p> <p>If dealing with small files, it is recommended to write the final file to a <code>MemoryManagerStream</code>, and use that stream to fulfill read requests; as reading small files from disk is slow. </p> <p>For big files (&gt;100MB) or where the total expected sum of the files is big (2GB+), consider writing them to disk, and fulfilling the read requests from disk.</p>"},{"location":"implementation-rules.html","title":"Implementation Rules","text":""},{"location":"implementation-rules.html#implementation-rules","title":"Implementation Rules","text":"<p>Danger</p> <p>Please do not implement hacks for things such as <code>hotswapping</code> files at runtime by serving different data on future loads; or writing to buffers passed by the application. Not only are these hard to debug but emulators should be as application agnostic as possible.  </p> <p>APIs to enable those features can be provided for other mods to use (e.g. via Dependency Injection), but must not be enabled by default.  </p> <p>This framework prioritises performance and compatibility first.  </p>"},{"location":"implementation-rules.html#always-stream-if-possible","title":"Always Stream if Possible","text":"<p>Implement your emulator as a <code>Type A</code> whenever possible.  </p> <p>While <code>Type B</code> may be easier, since you can potentially simply use existing libraries with <code>MemoryManagerStream</code>, it will have a noticeable impact on first load time; and the increased memory usage may lead to increased swapping to/from pagefile. The pagefile also has limits.</p>"},{"location":"implementation-rules.html#memory-usage","title":"Memory Usage","text":"<p>Warning</p> <p>Use memory mapped files for small files only. It is suggested to write bigger files (&gt;100MB) out to disk directly.</p> <p>If using using <code>Type B</code> emulation, use memory mapped files (<code>MemoryManager</code> &amp; <code>MemoryManagerStream</code>) when possible. Failure to do so risks virtual address space starvation in 32-bit processes.  </p> <p>When using memory mapped files, only sections that are currently mapped/viewed use up the address space, in the case of <code>MemoryManager</code>, this means only <code>AllocationGranularity</code> is used.  </p>"},{"location":"implementation-rules.html#use-lazy-loading-immutability","title":"Use Lazy Loading &amp; Immutability","text":"<p>Implementations should only produce/initialize emulated files when they are first requested by the application; i.e. when a handle is opened.  </p> <p>Once produced, the file emulator should always serve the same file on subsequent requests/handle openings. i.e. generated files persist for application lifetime.</p>"},{"location":"implementation-rules.html#always-read-all-requested-bytes","title":"Always Read All Requested Bytes","text":"<p>Info</p> <p>A common programmer error is to issue a <code>Read()</code> command on a file stream and assume that all bytes requested will be given back.</p> <p>This is not often the case and even I have been guilty of this mistake for a very long time. If possible, DO NOT return less than the number of bytes requested (when possible) in order to shield against buggy software implementations.  </p> <p>While this may sound more complicated than it should for e.g. archives, it really should not be. If you have some code for an archive emulator's <code>ReadData</code> that looks something like:</p> <pre><code>// If getting header in Type-A emulator\nif (isHeaderRead)\n{\n// We are reading the file header, let's give the program the false header.\nvar fakeHeaderSpan = new Span&lt;byte&gt;(afsFile.HeaderPtr, afsFile.Header.Length);\nvar endOfHeader = offset + length;\nif (endOfHeader &gt; fakeHeaderSpan.Length)\nlength -= (uint)(endOfHeader - fakeHeaderSpan.Length);\n\nvar slice = fakeHeaderSpan.Slice((int)offset, (int)length);\nslice.CopyTo(bufferSpan);\n\nnumReadBytes = slice.Length;\nreturn true;\n}\n\n// Else we are reading a file, let's pass a new file to the buffer.\nif (afsFile.TryFindFile((int)offset, (int)length, out var virtualFile))\n{\nnumReadBytes = virtualFile.GetData(bufferSpan);\nreturn true;\n}\n</code></pre> <p>Then you can just invoke this function multiple times until the requested amount of bytes have been filled.</p> <p>Tip</p> <p>A recommended way of building stream (Type A) based emulators emulators is MultiStream. With MultiStream you can avoid this issue entirely, and usually implement <code>ReadData</code> in ~5 lines. </p>"},{"location":"implementation-rules.html#hooks-always-enabled","title":"Hooks Always Enabled","text":"<p>Don't deactivate your hooks at any point. All hooks should always be enabled to allow for recursive use of the emulators.</p>"},{"location":"implementation-rules.html#data-access-patterns","title":"Data Access Patterns","text":"<p>Tip</p> <p>Assume data can be accessed in any order, and reads may begin from any offset and/or length.  </p>"},{"location":"implementation-utilities.html","title":"Utilities","text":""},{"location":"implementation-utilities.html#high-performance-logging","title":"High Performance Logging","text":"<p>Tip</p> <p>The <code>Logger</code> class in <code>FileEmulationFramework.Lib</code> provides an abstraction over Reloaded's <code>ILogger</code> that allows you to conditionally make log messages without the need for memory allocation.  </p> <pre><code>_log = new Logger(_logger, _configuration.LogLevel);\n</code></pre> <p>Methods such as <code>_log.Info</code> will only create the string and log it if that specific log level is enabled; provided you use the various overloads that accept generics e.g. <code>Info&lt;T1&gt;(string format, T1 item1)</code>.</p> <p>Avoid the overloads with single message parameter unless you require custom formatting; in which case you should add manual guards via <code>if (_log.IsEnabled(level))</code>.</p>"},{"location":"implementation-utilities.html#file-slices","title":"File Slices","text":"<p>Info</p> <p>The <code>FileSlice</code> class can be used to provide an abstraction that allows you to read a region of a given file.  </p> <p>When building Stream based emulators, you will often provide a mixture of the original data and new data. This class will allow you to more easily fetch the original data when needed.</p>"},{"location":"implementation-utilities.html#merging-file-slices","title":"Merging File Slices","text":"<p>Info</p> <p>Slices of the same file that touch each other (e.g. <code>0-4095</code> + <code>4096-65536</code>) can be merged into singular, larger slices.  </p> <p>This is sometimes possible when working with archives containing file data whereby multiple files are laid out side by side.</p> <p>Tip</p> <p>Merging can help improve performance of resolving <code>Read</code> requests (i.e. <code>IEmulator.ReadData</code>). Specifically the performance of StreamMixer</p> <p>Try using the <code>FileSlice.TryMerge</code> API.  </p> <p>If you are using streams backed by <code>FileSlice</code> (that use <code>IFileSliceStream</code>), you can merge them using <code>FileSliceStreamExtensions.TryMerge</code> for individual streams or <code>FileSliceStreamExtensions.MergeStreams</code> for collections.  </p>"},{"location":"implementation-utilities.html#file-slice-stream","title":"File Slice Stream","text":"<p>Info</p> <p>The <code>FileSliceStream</code> classes provide an abstraction that wrap <code>FileSlice</code>(s). Currently two implementations exist, <code>FileSliceStreamFs</code> and <code>FileSliceStreamW32</code>.  </p> <p>Tip</p> <p><code>FileSliceStreamFs</code> is backed by FileStream. Use this class if application makes many reads with small amount of data (e.g. &lt;= 256 byte reads.)</p> <p>Tip</p> <p><code>FileSliceStreamW32</code> is backed by Windows API. Use this class if reads above 4096 bytes are expected.</p> <p>Should be simple enough.</p>"},{"location":"implementation-utilities.html#offsetrange","title":"OffsetRange","text":"<p>A utility class that stores a start and end offset [inclusive]. Can be used for testing for overlaps, testing of address is in range, etc.</p>"},{"location":"implementation-utilities.html#multi-stream","title":"Multi Stream","text":"<p>Info</p> <p><code>MultiStream</code> combines multiple streams into a single stream with read and seek support. Highly optimised.</p> <p>Tip</p> <p>It is possible to build entire files using this stream and just resolve read requests <code>IEmulator.ReadData</code> by seeking and reading from this stream. This is a recommended approach.</p>"},{"location":"implementation-utilities.html#padding-stream","title":"Padding Stream","text":"<p>Info</p> <p>Stream that fills the read buffer with a single, user specified byte.  </p> <p>This can be used in conjunction with MultiStream to provide padding for emulated files.</p>"},{"location":"implementation-utilities.html#mathematics","title":"Mathematics","text":"<p>Info</p> <p>This class has some common mathematics related operations, such as rounding up numbers to add padding to files.</p>"},{"location":"implementation-utilities.html#fast-directory-searcher","title":"Fast Directory Searcher","text":"<p>Tip</p> <p>The <code>WindowsDirectorySearcher</code> class can be used for extremely fast searching of files on the filesystem. </p> <p>This implementation is around 3.5x faster than the built in .NET one at the time of writing; using the innermost <code>NtQueryDirectoryFile</code> API for fetching files.</p> <p>It's forked from the implementation in <code>Reloaded.Mod.Loader.IO</code>; with Multithreading removed since it wouldn't be helpful with our too small data/file sets.</p>"},{"location":"routing.html","title":"Routing","text":"<p>Info</p> <p>This page describes the basics of how files on disk are used to modify existing files through the use of 'emulators'.</p> <p>When virtual/emulated files are being built, the library keeps track of a <code>Route</code>.  </p> <p>This 'route' is a combination of the base file, and the name of each recursive internal file(s): - Base file uses full path, e.g. <code>&lt;GameFolder&gt;/English/Sound.afs</code>. - Internal files are delimited by <code>/</code> character.  </p> <p>e.g. File <code>00000.adx</code> in <code>&lt;GameFolder&gt;/English/Sound.afs</code> would make the full path <code>&lt;GameFolder&gt;/English/Sound.afs/00000.adx</code>.  </p> <p>This route is passed onto the individual <code>emulators</code> to work with.  </p>"},{"location":"routing.html#file-resolution","title":"File Resolution","text":"<p>Info</p> <p>Describes how files in user mods are matched to the file to be modified.  </p> <p>Each emulator will have its own folder under the <code>FEmulator</code> folder inside user made mods, so the emulator for CRIWARE <code>.AFS</code> would use <code>FEmulator/AFS</code>.  </p> <p>Folder names are used for resolving what files should be modified by each 'emulator'; with the folder name corresponding to the file to modify and the contents of the folder being the input to the 'emulator'.  </p> <p>In the case of 'archive emulators' like the AFS ones, placing files inside can be used to override existing files inside the source <code>.afs</code> file.</p> <ul> <li>Folder <code>Sound.afs/00000.adx</code> in <code>FEmulator/AFS</code> will override files named <code>00000.adx</code> in all <code>Sound.afs</code> loaded.  </li> </ul> <p>Additional folders can be used to specify the file to be overwritten more precisely. This can be useful when multiple files of the same name exist.  </p> <p>For example, <code>English/Sound.afs/00000.adx</code> in <code>FEmulator/AFS</code>: - Will match <code>&lt;GameFolder&gt;/English/Sound.afs</code> - Will not match <code>&lt;GameFolder&gt;/Japanese/Sound.afs</code> </p> <p>Comparisons performed are case insensitive. Partial matches e.g. <code>nglish/Sound.afs</code> are allowed, but are discouraged from use.</p>"},{"location":"routing.html#recursive-resolution","title":"Recursive Resolution","text":"<p>Info</p> <p>Emulators work recursively.  Meaning you can emulate a file inside an emulated file.</p> <p>In the case of archives, suppose you have <code>textures.one</code> and inside that <code>textures.txd</code>.  </p> <p>You can inject into <code>textures.txd</code> by doing the following: - Add <code>FEmulator/ONE/textures.one/textures.txd</code>.  [inject unmodified <code>textures.txd</code> into <code>textures.one</code>]. - Add <code>FEmulator/TXD/textures.txd/texture_001.dds</code>. [inject texture_001 into <code>textures.txd</code>]  </p>"},{"location":"routing.html#file-usage","title":"File Usage","text":"<p>The File Resolution section used the 'AFS Redirector' as an example of inserting/replacing files into an archive by using existing files.  </p> <p>The contents of the folder corresponding to the emulated file are open to the emulator's interpretation.  </p> <p>For example, for an ADX (sound file) emulator, <code>Musictrack.adx/settings.json</code> could be a valid file; and the emulator use <code>settings.json</code> to perform post processing the file such as sound normalization or concatenating music tracks.  </p> <p>Equally well, for archives which use compression for internal files, having pre-compressed files is also valid.</p>"},{"location":"emulators/afs.html","title":"AFS [CRI Middleware]","text":"<p>Info</p> <p>AFS is a general purpose data container from CRI Middleware. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/afs.html#supported-applications","title":"Supported Applications","text":"<p>This emulator should support every application out there.  </p> <p>It has been tested with the following: - Sonic Heroes (PC) - Silent Hill 3 (PC) - Sonic Adventure 2 (PC) - Shadow The Hedgehog (Japanese, GameCube, Dolphin Emulator, Running from FileSystem)  </p>"},{"location":"emulators/afs.html#example-usage","title":"Example Usage","text":"<p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.afs\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/AFS</code> in your mod folder. C. Make folders corresponding to AFS Archive names, e.g. <code>SH_VOICE_E.AFS</code>.  </p> <p>Files inside AFS Archives are accessed by index, i.e. order in the archive: 0, 1, 2, 3 etc.  </p> <p>Inside each folder make files, with names corresponding to the file's index.  </p>"},{"location":"emulators/afs.html#examples","title":"Example(s)","text":"<p>To replace a file in an archive named <code>EVENT_ADX_E.AFS</code>...</p> <p>Adding <code>FEmulator/AFS/EVENT_ADX_E.AFS/0.adx</code> to your mod would replace the 0th item in the original AFS Archive.</p> <p>Adding <code>FEmulator/AFS/EVENT_ADX_E.AFS/32.aix</code> to your mod would replace the 32th item in the original AFS Archive.</p> <p></p> <p>File names can contain other text, but must start with a number corresponding to the index.  </p> <p>Info</p> <p>For audio playback, you can usually place ADX/AHX/AIX files interchangeably. e.g. You can place a <code>32.adx</code> file even if the original AFS archive has an AIX/AHX file inside in that slot. </p> <p>Info</p> <p>A common misconception is that AFS archives can only be used to store audio. This is in fact wrong. AFS archives can store any kind of data, it's just that using AFS for audio was very popular.</p> <p>Info</p> <p>If dealing with AFS audio; you might need to make sure your new files have the same channel count as the originals.   </p>"},{"location":"emulators/arc.html","title":"ARC [JSRF]","text":"<p>Info</p> <p>ARC (or ARCL) is a archive format used in Jet Set Radio. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/arc.html#supported-applications","title":"Supported Applications","text":"<p>This emulator should support every application that uses ARCs (though they have only been found in Jet Set Radio).  </p> <p>It has been tested with the following: - Jet Set Radio HD (PC)</p>"},{"location":"emulators/arc.html#example-usage","title":"Example Usage","text":"<p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.arc\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/ARC</code> in your mod folder. C. Make folders corresponding to ARC Archive names, e.g. <code>IMAGES.ARC</code>.  </p> <p>Files inside ARC Archives are accessed by the path and filename.  </p> <p>Inside each folder make files, with names corresponding to the original file's contents.  </p>"},{"location":"emulators/arc.html#examples","title":"Example(s)","text":"<p>To replace a file in an archive named <code>IMAGES.ARC</code>...</p> <p>Adding <code>FEmulator/ARC/CUSTOM/IMAGES.ARC/arrow.png</code> to your mod would replace the item at <code>arrow.png</code> in the original ARC Archive.</p> <p>Adding <code>FEmulator/ARC/CUSTOM/IMAGES.ARC/PS3/button_a.png</code> to your mod would replace the item at <code>/PS3/button_a.png</code> in the original ARC Archive.</p> <p>The contents of each ARC file can be found using the JSR ARC Tool, found here.</p> <p>Info</p> <p>The files that are being replaced must be the same file format as the new files, you cant replace a .PNG with a .JPG!</p>"},{"location":"emulators/awb.html","title":"AWB [CRI Middleware]","text":"<p>Info</p> <p>AWB is a general purpose data container from CRI Middleware. It's the successor to AFS and uses the header AFS2. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/awb.html#supported-applications","title":"Supported Applications","text":"<p>This emulator should support every application out there.  </p> <p>It has been tested with the following: - Bayonetta (PC) - Persona 5 Royal (PC) [Note: ADX files Require Encryption]  </p>"},{"location":"emulators/awb.html#example-usage","title":"Example Usage","text":"<p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.awb\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/AWB</code> in your mod folder. C. Make folders corresponding to AWB Archive names, e.g. <code>BGM000.AWB</code>.  </p> <p>Files inside AWB Archives are accessed by index, i.e. order in the archive: 0, 1, 2, 3 etc.  </p> <p>Inside each folder make files, with names corresponding to the file's index.  </p>"},{"location":"emulators/awb.html#examples","title":"Example(s)","text":"<p>To replace a file in an archive named <code>BGM000.AWB</code>...</p> <p>Adding <code>FEmulator/AWB/BGM000.AWB/0.adx</code> to your mod would replace the 0th item in the original AWB Archive.</p> <p>Adding <code>FEmulator/AWB/BGM000.AWB/32.aix</code> to your mod would replace the 32th item in the original AWB Archive.</p> <p></p> <p>File names can contain other text, but must start with a number corresponding to the index.  </p>"},{"location":"emulators/awb.html#acb-bdx-patching","title":"ACB &amp; BDX Patching","text":"<p>Info</p> <p>When an AWB is accompanied by an ACB file, the header of the AWB file is usually ignored and instead read from ACB which makes life difficult.  </p> <p>When the emulator sees an ACB file, it will automatically try to match any found AWB header with previously patched AWB and patch it inside the ACB if there's a match. </p> <p>Warning</p> <p>In some cases, the ACB may be loaded BEFORE the AWB, in which case the emulator will try load the AWB by replacing the extension of the file from <code>.acb</code> to <code>.awb</code>.  </p> <p>If you run into a title where the ACB and AWB names don't match and require custom file linking, let me know.</p>"},{"location":"emulators/awb.html#notes-afs","title":"Notes (AFS)","text":"<p>The following notes/limitations are known to exist in AFS, and may still apply in AWB, they have been untested.</p> <p>Info</p> <p>For audio playback, you can usually place ADX/AHX/AIX files interchangeably. e.g. You can place a <code>32.adx</code> file even if the original AWB archive has an AIX/AHX file inside in that slot. </p> <p>Info</p> <p>If dealing with AWB audio; you might need to make sure your new files have the same channel count as the originals.   </p>"},{"location":"emulators/one-heroes.html","title":"ONE [Sonic Heroes]","text":"<p>Info</p> <p>.ONE is a general purpose data container developed (presumably) at some branch of Sonic Team.  This emulator is for the Sonic Heroes variant. Code for thie emulator lives inside the main project's GitHub repository.  </p>"},{"location":"emulators/one-heroes.html#supported-applications","title":"Supported Applications","text":"<ul> <li>Sonic Heroes (PC)  </li> <li>Sonic Heroes XBOX (Emu)  </li> </ul> <p>and any tools that operate on the format...  </p>"},{"location":"emulators/one-heroes.html#example-usage","title":"Example Usage","text":"<p>A. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.heroes.one\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/ONE</code> in your mod folder. C. Make folders corresponding to ONE Archive names, e.g. <code>game_disp.one</code>.  </p> <p>Put files inside that folder to perform various actions.  </p> <p>Info</p> <p>Refer to Routing if you want to use more specific file names.</p>"},{"location":"emulators/one-heroes.html#addingreplacing-files","title":"Adding/Replacing Files","text":"<p>Warning</p> <p>Uncompressed files will suffer from a small load time penalty upon first load of the file, since they will need to be compressed as the ONE format does not support uncompressed files.  </p> <p>Simply place the file in your <code>.one</code> directory.  </p> <p></p> <p>(game_disp.one/GAME_DISP.TXD)</p> <p>Files placed in the directory will replace the files stored inside the ONE archive.  </p> <p>Tip</p> <p>You should pre-compress your files using this tool to avoid load time penalties. Recommend buffer size of 8191.  </p> <p>Add <code>.PRS</code> extension to compressed files. e.g. <code>GAME_DISP.TXD.PRS</code>.  </p> <p>Danger</p> <p>Seriously, please compress your files.  Uncompressed files are backed by pagefile, overuse of those may lead to performance problems.</p> <p>Note</p> <p>Pre-compressing files prevents them from working with other emulators. If there would hypothetically be, a TXD emulator some day; and you want to merge some textures in; don't pre-compress your TXD.  </p>"},{"location":"emulators/one-heroes.html#deleting-files","title":"Deleting Files","text":"<p>In order to delete a file, create an empty file with the name of the file and extension <code>.del</code>.</p> <p></p> <p>e.g. This would remove the file <code>GAME_DISP.TXD</code> from the original archive.  </p> <p>Note</p> <p>The archive builder works in the order <code>Delete</code> then <code>Add</code>. If a file is first deleted, it can be re-added by either the same or another mod.  </p>"},{"location":"emulators/pak.html","title":"PAK [Atlus]","text":"<p>Info</p> <p>PAK is a general purpose data container used by Atlus. Code for this emulator lives inside main project's GitHub repository.  </p>"},{"location":"emulators/pak.html#file-types","title":"File Types","text":"<p>This emulator should work with type of PAKs, regardless of what the actual file is named. </p> <p>The most common names/extensions for PAKs are: - PAK - BIN - PAC - ARC</p>"},{"location":"emulators/pak.html#supported-applications","title":"Supported Applications","text":"<p>The only games that have so far been found to use PAKs are Persona games, but theoretically should work with any game that uses them.</p> <p>It has been tested with the following: - Persona 3 Portable (PC) - Persona 4 Golden (PC) - Persona 5 Royal (PC)  </p>"},{"location":"emulators/pak.html#example-usage","title":"Example Usage","text":"<p>A. As currently this mod is for the PC releases of Persona games, you will need to use the extension of Persona Essentials to use with those games. The steps for using on its own are very similar to with that extension. Add a dependency on this mod in your mod configuration. (via <code>Edit Mod</code> menu dependencies section, or in <code>ModConfig.json</code> directly)</p> <pre><code>\"ModDependencies\": [\"reloaded.universal.fileemulationframework.pak\"]\n</code></pre> <p>B. Add a folder called <code>FEmulator/PAK</code> in your mod folder. C. Make folders corresponding to PAK Container names, e.g. <code>init_free.bin</code>.  </p> <p>Files inside PAK Archives are accessed by the name of the original file, i.e. if you want to replace a file called file.tmx in the archive, you would add a file also called file.tmx into your folder.  </p> <p>Inside each folder make files, with names corresponding to the file's name, if the file's name contains a folder path, place the file in a folder of the same name. e each folder make files, with names corresponding to the file's name, if the file's name contains a folder path, place the file in a folder of the same name.  </p>"},{"location":"emulators/pak.html#paks-within-paks","title":"PAKs within PAKs","text":"<p>Various PAK files in the Persona series use PAK files nested within other PAK files. </p> <p>To edit these nested PAKs, simply make a folder within the PAK file folder you already made with the same name as the nested PAK file.</p>"},{"location":"emulators/pak.html#examples","title":"Example(s)","text":"<p>To replace a file in an archive named <code>init_free.bin</code>...</p> <p>Adding <code>FEmulator/PAK/init_free.bin/file.tmx</code> to your mod would add or replace a file named <code>file.tmx</code> in the original PAK Container.</p> <p>Adding <code>FEmulator/PAK/init_free.bin/field/fldEff_rainA.tmx</code> to your mod would add or replace a file named <code>field/fldEff_rainA.tmx</code> in the original PAK Container.</p> <p>Adding <code>FEmulator/PAK/init_free.bin/init/loading.arc/mini_tv.tmx</code> to your mod would add or replace a file named <code>mini_tv.tmx</code> in the PAK file <code>loading.arc</code> within the original PAK Container.</p>"},{"location":"guides/contributing-locally.html","title":"Contributing to the Index: Locally","text":""},{"location":"guides/contributing-locally.html#tutorial","title":"Tutorial","text":"<p>You should learn the basics of <code>git</code>, an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00.</p> <ol> <li>Create a GitHub account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Clone this repository.</p> <p>For example, using GitHub Desktop: </p> </li> <li> <p>Make changes inside the <code>docs</code> folder.</p> <p></p> <p>Consider using a Markdown Cheat Sheet if you are new to markdown.</p> <p>I recommend using a markdown editor such as <code>Typora</code>. Personally I use Visual Studio Code, which has built-in markdown support and preview available (<code>Ctrl+Shift+P</code> -&gt; <code>Markdown: Open Preview</code>). </p> </li> <li> <p>Commit the changes and push to GitHub.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"},{"location":"guides/contributing-locally.html#website-live-preview","title":"Website Live Preview","text":"<p>If you are working on the Index locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your <code>command prompt</code> (cmd).</p> <ol> <li> <p>Install Python 3</p> <p>If you have <code>winget</code> installed, or Windows 11, you can do this from the command prompt. <pre><code>winget install Python.Python.3\n</code></pre></p> <p>Otherwise download Python 3 from the official website.</p> </li> <li> <p>Install Material for MkDocs (Python package)     <pre><code># Restart your command prompt before running this command.\npip install mkdocs-material\n</code></pre></p> </li> <li> <p>Open a command prompt in the Index folder and run the site locally.     <pre><code># Move to Index folder.\ncd &lt;Replace this with full path to your Index folder&gt;\nmkdocs serve\n</code></pre></p> <p></p> <p>Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.</p> </li> </ol>"},{"location":"guides/contributing-online.html","title":"Contributing to the Index: Online","text":"<p>(If you want to work purely in your web browser, recommended for small changes only)</p> <ol> <li>Create a GitHub Account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Open the <code>docs</code> folder and edit the relevant (.md) pages.</p> <p></p> <p>Consider using a Markdown Cheat Sheet for your editing needs.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"}]}